import Page from "@reason/pages/Docs";
export default Page({ title: "Snapps: SNARK Powered Applications" });

# Snapps: Приложения на базе SNARK

<Alert kind="warning">

  Начиная с версии `0.0.16-beta7` эта функция была отключена и может быть активирована только путем включения флага времени сборки. Мы планируем включить эту функцию в будущих релизах.

</Alert>

### Snapps = децентрализованные приложения (Dapps) + приватность + офчейн данные + масштабируемость

Будучи самым легким блокчейном в мире, Mina предлагает совершенно новую категорию приложений под названием Snapps <Footnote refNumber="[3]" link="/disclaimers" /> : Snarkified Applications. Snapps функционально похожи на децентрализованные приложения (Dapps) на платформе Ethereum, но превосходят их благодаря трем особым свойствам:

1. Проверка целостности частей данных, не раскрывая их.
2. Проверка правильности выполнения дорогостоящих вычислений.
3. Значительные преимущества масштабируемости.

Эти типы приложений не обязательно новые. В некотором смысле оба приложения существуют как современные блокчейны: ZCash как Snapp со свойством 1 и Mina как Snapp со свойством 2.

Snapp также значительно более эффективен, чем Dapp в Ethereum. Чтобы мировой компьютер Ethereum взял на себя обязательство перед своими пользователями по задействованию Dapp, каждая нода и майнер в сети должны выполнять одни и те же вычисления. Это неприлично неэффективно. С помощью Snapp на базе Mina, Snapp запускается разработчиком, после чего все остальные ноды могут просто верифицировать соответствующее SNARK доказательство. Подобное утверждение может быть применено к Dapps второго уровня на базе SNARK в Ethereum, однако эти Dapps по-прежнему обременены ограниченной пропускной способностью основной цепочки, тогда как Snapp на базе Mina извлекает выгоду из потенциала масштабируемости блокчейна Mina благодаря его сжатой структуре.

В общем плане, Snapp в сети Mina работает следующим образом:

1. Определяет код для запуска, раскрывает его исходный код, если он еще не был открыт
2. Использует код для развертывания схемы SNARK путем вызова функции в сети Mina
3. Получает данные для выполнения вычислений 
4. Вызывает функции с соответствующими данными
5. Выполняет вычисления в цепочке, аналогично смарт-контракту [готово через 6-12 месяцев после mainnet]
6. Присоединяет SNARK доказательство, возвращенное из функции, к адресу Mina
7. Mina проводит транзакции на основе результатов SNARK доказательств

## Технический обзор 

В нынешнем виде, Mina's Snapps будет работать следующим образом.

- Появится новый вид учетной записи, называемой “Snapp аккаунт”, в которой помимо открытого ключа и баланса также будет храниться ключ проверки Pickles SNARK K и состояние S, состоящее из небольшого массива элементов поля. 
- Появится новый вид транзакции, называемый “Single Snapp-транзакция”, что позволит выполнять переход в стандартную учетную запись и обратно, а также обновлять состояние Snapp. Оно будет содержать:

  - Стандартный адрес учетной записи
  - Адрес Snapp аккаунта
  - Подписанную сумму “snapp_account_delta”, которая отображает изменение баланса для Snapp аккаунта
  - Опциональное новое состояние “snapp_new_state” для Snapp аккаунта
  - Подпись транзакции из стандартной учетной записи, если snapp_acount_delta > 0
  - Доказательство Pickles SNARK, которое будет проверяться (с помощью ключа подтверждения Snapp аккаунта) на соответствие с утверждением, включающим
    - snapp_account_delta : SignedAmount
    - snapp_prev_state : Array&lt;Field>
    - snapp_new_state : Array&lt;Field>

  В результате проведения этой транзакции будет обновлено состояния Snapp, изменено Snapp баланс с помощью snapp_acount_delta и баланс стандартной учетной записи с помощью -snapp_account_delta.

- Появится новый вид транзакции, называемый “Double Snapp транзакция”, что позволит одновременно обновлять состояния (и переводить средства между) двумя Snapp аккаунтами.
- Оно будет содержать:

  - Адрес Snapp аккаунта “address1”
  - Адрес Snapp аккаунта “address2”
  - Подписанную сумму account1_delta, которая отображает изменение баланса для первого аккаунта
  - Два опциональных новых состояния “account1_new_state” и “account2_new_state”
  - Подпись транзакции из стандартного аккаунта, если snapp_acount_delta > 0
  - Два доказательства SNARK Pickles proof1, proof2, которые для i = 1, 2 должны проверяться (с помощью i’s ключа проверки аккаунта) на соответствие с утверждением, включающим
    - account1_delta : SignedAmount
    - account1_prev_state : Array&lt;Field>
    - account1_new_state : Array&lt;Field>
    - account2_prev_state : Array&lt;Field>
    - account2_new_state : Array&lt;Field>

  В результате проведения этой транзакции будет обновлено оба состояния аккаунтов, изменен account1’s баланс с помощью account1_delta и account2’s баланс с помощью -account1_delta.

В настоящее  время O(1) Labs разрабатывает для разработчиков приложений инструментарий, который содержит уже существующие инструменты, такие как [snarky](https://github.com/o1-labs/snarky), для облегченной разработки Snapps и выполнения вычислений SNARK доказательств с помощью одного нажатия кнопки. Инструментарий будет совместим с Mina по умолчанию, предоставляя Snapps простой способ определения состояния и получения и финансовой ценности.

Рассмотрим пару примеров, которые продемонстрируют истинную мощь Snapps.

## Примеры

### Пример 1: Подтверждение кредитного рейтинга

**Ценностное предложение: **Предоставление заемщикам возможности доказать, что их кредитный рейтинг превышает определенный порог, без раскрытия самого рейтинга, и, таким образом, предоставление возможность занимать средства без предоставления каких-либо гарантий.

**Пример пользовательского потока:**

- Пользователь посещает сайт кредитора
- Is asked to download cryptographically signed information from a credit score provider such as CreditKarma
- Website locally checks if credit score is above threshold and computes SNARK proof returning the result
- SNARK proof and result are attached to the Mina address of the user and is shared with the cloud system of the lender (could also be a smart contract)
- Lender verifies the SNARK proof and passing of threshold
- Loan is provided to the Mina address in stablecoins, if it meets criteria

**How Snapp Toolset Is Used: **Developer of Snapp uses the toolset to integrate a specific program that has the user download a signed credit score from provider, check locally on the user’s computer that the score meets criteria, and locally generate a proof for the check, which is subsequently shared back with the developer. The toolset also provides the user with a Mina address behind the scenes, which is used to provide a time stamp to the computation via the block number on the Mina blockchain. They also use the toolset to integrate a SNARK verifier into their own backend to confirm the validity of the local computation.

### Example 2: Proof of Authentic Identity Document

**Value Proposition: **Proving that the owner of a Mina address has access to an authentic identity document (such as driver’s license), without disclosing the document itself, starting with a certain block height. The validity of the identity document would be checked by a standardized open source algorithm.

**Example User Flow:**

- User visits website, downloads app to laptop or mobile phone
- Uses app to scan ID, verify its authenticity
- App also creates Mina wallet for user
- App associates SNARK proof with Mina address of user, along with hash of the photo of the ID
- User visits another website that asks for authentic identity. Is able to share the ID proof, along with a hash of their ID, to confirm their Mina address has claim over an authentic ID

**How Snapp Toolset Is Used: **Snapp toolset provides the developer with an SDK to embed into their app the SNARK proof generator and hash generator, along with a Mina interface. Snapp toolset also provides any other developer that wants to be able to verify said ID authentications with a SNARK verifier.

### Example 3: Proof of Coinbase Balance

**Value Proposition: **Providing third parties with proof of funds meeting a certain criteria (e.g. >\$10,000) in a Coinbase account belonging to a specific email, without disclosing the actual deposit amount.

**Example User Flow:**

- User visits a lending application. In order to borrow funds, they’re asked to have at least >\$10,000 of Bitcoin in their Coinbase account.
- User OAuths into their Coinbase account
- The website locally checks user’s balance and email, both signed by Coinbase’s keys
- Website locally generates SNARK proof that user’s balance is >\$10,000
- SNARK proof is attached to the Mina address of the user
- User signs their ownership of the SNARK proof using their Mina address, and shares the email address of their Coinbase account with the backend of the lending application.

**How Snapp Toolset Is Used: **Developer of Snapp uses the toolset to integrate a specific program that has the user OAuth into their Coinbase account, query their account balance for a signed balance information, the account’s email address, and a time stamp. The toolset allows a SNARK proof to be generated locally, without sharing any information with the backend of the service provider, so all balance info stays private. The developer also uses the toolset to integrate a SNARK verifier into their own backend to confirm the validity of the local computation.

### Example 4: Private Voting

**Value Proposition:** Allowing a set of eligible voters (e.g. any Twitter account with >100 followers) to vote privately, without disclosing who they are and what they voted for. Anyone would easily be able to verify the outcome of the entire vote once the voting period is over.

**Example User Flow:**

- User can prove ownership of a given account by exhibiting the HTTPS transcript of them successfully logging into twitter.com. To authenticate and vote, they will prove (public input in orange), “I know an account A with password P and a valid login transcript for (A, P) and hash(A, P) = **N** and my vote is for option **V**”. **N** is called a “nullifier” and is unique to a given user/password combination and is used to prevent double voting.
- In a fully decentralized mode, the user can then use this proof to update the state of the election app on the Mina chain.
- In a higher throughput, partially decentralized mode, the user would send their zero knowledge proof to a proof-aggregator, who maintains the state of the election, and aggregates the user proofs together into one bundled together proof, which then gets posted to the Mina chain.
- When viewing the results of the election, the user obtains the main Mina blockchain proof, which certifies the validity of the entire Mina merkle tree, including the leaf corresponding to the election state. They also obtain a merkle path into this leaf so that they can view the state.

### Other Ideas

The design space for Snapps is huge, and will consist of many other innovative ideas entrepreneurs will come up with as the framework is better understood. Some other examples we have thought of:

- Proof of age using identity document
- Proof of citizenship using identity document
- Proof of salary via bank account
- Proof of not doing an activity, e.g. blockchain address associated with a specific identity has not sent money to blacklisted wallet addresses, without disclosing address
- Proof of limited alterations to a document, e.g. resizing a validated photo

## Next Steps and Community Involvement

O(1) Labs is working hard to build the Snapp toolset which will make the above examples possible on the Mina blockchain, and partner with talented developers to build the first proof of concept implementations.

However, the sky's the limit for Snapps. As such, we would like to invite the Mina community to join us in ideating different Snapp use cases and user flows, as well as helping us develop the tools and apps by contributing to the code. If you would like to join the exploration of this entirely new design space for confidential and verifiable applications, start by filling out this [form](https://forms.gle/PsM1AmZMveE3RhaV8).
